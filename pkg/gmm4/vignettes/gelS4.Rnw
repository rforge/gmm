\documentclass[11pt,letterpaper]{article}
\usepackage{amsthm}

\usepackage[hmargin=2cm,vmargin=2.5cm]{geometry}
\newtheorem{theorem}{Theorem}
\newtheorem{col}{Corollary}
\newtheorem{lem}{Lemma}
\usepackage[utf8x]{inputenc}
\newtheorem{ass}{Assumption}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black
}

\bibliographystyle{plainnat}


\author{Pierre Chauss\'e}
\title{\textbf{Generalized Empirical Likelihood with R}}
\begin{document}

\maketitle

\newcommand{\E}{\mathrm{E}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\Prob}{\mathrm{Pr}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Vect}{\mathrm{Vec}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\conP}{\overset{p}{\to}}
\newcommand{\conD}{\overset{d}{\to}}
\newcommand\R{ \mathbb{R} }
\newcommand\N{ \mathbb{N} }
\newcommand\C{ \mathbb{C} }
\newcommand\rv{{\cal R}}
\newcommand\Q{\mathbb{Q}}
\newcommand\PR{{\cal R}}
\newcommand\T{{\cal T}}
\newcommand\Hi{{\cal H}}
\newcommand\La{{\cal L}}
\newcommand\plim{plim}
\renewcommand{\epsilon}{\varepsilon}

\abstract{This an extention of the gmmS4 vignette, to explain how to
  use the package for generalized empirical likelihood estimation.}
%\VignetteIndexEntry{Generalized Empirical Likelihood with R}
%\VignetteDepends{gmm4}
%\VignetteKeywords{empirical likelihood, exponential tilting,
%euclidean empirical likelihood}
%\VignettePackage{gmm4}
%\VignetteEngine{knitr::knitr}
<<echo=FALSE>>=
library(knitr)
opts_chunk$set(size='footnotesize')
@ 

\newpage
\tableofcontents
\newpage

\section{A very brief review of the GEL method}
We present how to use the package to estimate models by the
Generalized Empirical Likelihood method (GEL) (see
\cite{newey-smith04} for the iid case and \cite{anatolyev05} for
weakly dependent processes). We assume that the reader has read the
gmmS4 vignette in which many classes and methods needed are
defined. We first describe the method without going into too much
details. The author can refer to the above papers for a detailed
description, or \cite{chausse10} who explains GEL estimation using the
gmm (\cite{gmm})package. 

The estimation is based on the following moment conditions 
\[
\E[g_i(\theta)]=0,   
\]
For the iid case, the estimator is defined as the solution to either

\[
 \hat{\theta} = \arg\min_{\theta,p_i} \sum_{i=1}^n h_n(p_i) 
\]
subject to,
\[
\sum_{i=1}^n p_ig_i(\theta) = 0 
\]
and
\[
\sum_{i=1}^n p_i=1,
\]
where $h_n(p_i)$ belongs to the following Cressie-Read family of discrepancies:
\[
 h_n(p_i) = \frac{[\gamma(\gamma+1)]^{-1}[(np_i)^{\gamma+1}-1]}{n}, 
\]
or
\begin{equation}\label{gel_obj}
 \hat{\theta} = \arg\min_{\theta}\left[\max_{\lambda} \frac{1}{n}\sum_{i=1}^n\rho\left(\lambda'g_i(\theta)\right)\right]
\end{equation}

The first is the primal and the second is the dual problem, the latter
being preferred in general to define GEL estimators. The vector
$\lambda$ is the Lagrange multiplier associated with the first
constraint in the primal problem. Its estimator plays an important
role in testing the validity of the moment conditions. $\rho(v)$ is a
strictly concave function normalized so that
$\rho'(0)=\rho''(0)=-1$. It can be shown that $\rho(v)=\ln{(1-v)}$
corresponds to Empirical Likelihood (EL) of \cite{owen01} ,
$\rho(v)=-\exp{(v)}$ to the Exponential Tilting (ET) of
\cite{kitamura-stutzer97}, and $\rho(v)=(-v-v^2/2)$ to the Continuous
Updated GMM estimator (CUE) of \cite{hansen-heaton-yaron96}. In the
context of GEL, the CUE is also known at the Euclidean Empirical
Likelihood (EEL), because it corresponds to $h_n(p_i)$ being the
Euclidean distance. 

Once the solution is obtained for $\theta$ and $\lambda$, the implied
probabilities can be computed as follows

\begin{equation}\label{imp_prob}
\hat{p}_i = \frac{\rho'(\hat{\lambda}'g_i(\hat{\theta}))}{\sum_{j=1}^n
  \rho'(\hat{\lambda}'g_j(\hat{\theta}))}
\end{equation}

If we relax the iid assumption, the problem is identical, but the
moment function must be smoothed using a kernel method. \cite{smith01}
proposes to replace $g_i(\theta)$ by:
\[
g^w_i(\theta) = \sum_{s=-m}^m w(s)g_{i-s}(\theta)
\]
where $w(s)$ are kernel based weights that sum to one (see also
\cite{kitamura-stutzer97} and \cite{smith01}. 

\section{An S4 class object for GEL models} \label{sec:gelmodels}

All classes for GEL models inherit directly from ``gmmModels''
classes. It is just a gmmModel class with two additional slots:
``gelType'' and ``wSpec''. The first is a list with the name of the
GEL method and a function for $\rho(v)$, if not already available in
the package. The second slot is used to store information about the
smoothing of $g_i(\theta)$ in the case of non-iid observations. As for
gmmModels, ``gelModels'' is a union class for ``linearGel'',
``nonlinearGel'', ``formulaGel'' and ``functionGel''. They inherit
directly from the associated GMM model class. For example,
``linearGel'' is a class that contains a ``linearGmm'' class object
and the two additional slots. The constructor is the gelModel()
function. We use the same models presented in the gmmS4
vignette:

<<>>=
library(gmm4)
data(simData)
@ 

\begin{itemize}
  \item Linear models:

<<>>=
lin <- gelModel(y~x1+x2, ~x2+z1+z2, data=simData, vcov="iid", gelType="EL")  
lin
@ 

\item Formula-type models:

<<>>=
theta0=c(mu=1,sig=1)
x <- simData$x1
dat <- data.frame(x=x, x2=x^2, x3=x^3, x4=x^4)
gform <- list(x~mu,
              x2~mu^2+sig, 
              x3~mu^3+3*mu*sig,
              x4~mu^4+6*mu^2*sig+3*sig^2)
form <- gelModel(gform, NULL, gelType="EEL", theta0=theta0, vcov="MDS", data=dat)
form
@ 

\item function:   
  
<<>>=  
fct <- function(theta, x)
    cbind(x-theta[1], (x-theta[1])^2-theta[2],
          (x-theta[1])^3, (x-theta[1])^4-3*theta[2]^2)
dfct <- function(theta, x)
    {
        m1 <- mean(x-theta[1])
        m2 <- mean((x-theta[1])^2)
        m3 <- mean((x-theta[1])^3)
        matrix(c(-1, -2*m1, -3*m2, -4*m3, 
                 0, -1, 0, -6*theta[2]), 4, 2)
    }
theta0=c(mu=1,sig2=1)
func <- gelModel(fct, simData$x3, theta0=theta0, grad=dfct, vcov="iid", gelType="ET")
func
@ 

\item Non-linear models:

<<>>= 
theta0=c(b0=1, b1=1, b2=1)
gform <- y~exp(b0+b1*x1+b2*x2)
nlin <- gelModel(gform, ~z1+z2+z3+x2, theta0=theta0, vcov="MDS", data=simData,
                 gelType="HD")
nlin
@
\end{itemize}

It is also posssible to convert an existing gmmModels to gelModels:

<<>>=
nlin <- gmmModel(gform, ~z1+z2+z3+x2, theta0=theta0, vcov="MDS", data=simData)
nlin <- gmmToGel(nlin, gelType="HD")
@ 

\subsection{The rhoXXX functions}

The package provides $\rho(v)$ for ET, EL, EEL and HD. The function
names are respectively ``rhoET'', ``rhoEL'', ``rhoEEL'' and ``rhoHD''.
For any other GEL, users can pass user specific $\rho(v)$ function to
the rhoFct argument of the gelModel(). The following example shows how
the function must be built:

<<>>=
rhoEL
@ 

Therefore, the function must be in the form $f(X,\lambda,d,k)$, where
the first argument is an $n\times q$ matrix, the second argument is a
vector of $q$ elements, the third is an integer that indicates the
order of derivative to return, and the last is a scalar that depends
on the kernel used to smooth the moment function. We will discuss that
in more details below. The function must return the vector $\rho(k
X\lambda)$, $\rho'(k X\lambda)$ or $\rho''(k X\lambda)$, when derive
is 0, 1, or 2, where $\rho'(v)$ and $\rho''(v)$ are the first and
second derivative of $\rho(v)$.

\subsection{The Lagrange multiplier solver}

The function getLambda() function solve the maximization problem 
\[
\max_\lambda \frac{1}{n} \sum_{i=1}^n \rho(\lambda'X_i)
\]
It is used to solve problem (\ref{gel_obj}). The arguments are:

<<>>=
args(getLambda)
@ 

The first argument is the $n\times q$ matrix $X$. The second argument
is the starting value for $\lambda$. If set to NULL, a vector of
zeroes is used. The third argument is the GEL type, which is either
"ET", "EL", "EEL", "REEL" or "HD". If the rhoFct is provided, getType
is ignored. The argument control is used to pass a list of arguments
to optim(), nlminb() or constrOptim(). The argument ``k'' is the
scalar described in the previous subsection. To describe all other
arguments, we are presenting the options by type of GEL:

\begin{itemize}
\item EL: There are three possible options for EL. The default is
  ``nlminb'', in which case, the arguments tol, maxiter and method are
  ignored. If algo is set to ``optim'', the solution is obtained using
  constrOptim(), with the restriction $(1-\lambda'X_i)>0$ for all
  $i$. If algo is set to ``Wu'', the \cite{wu05} algorithm is
  used. The argument tol and maxit are used to control the stopping
  rule. 

\item HD: Identical to EL, except that the ``Wu'' algorithm is not
  available for that type of GEL.

\item EEL: There is an analytical solution, so all other arguments are
  ignored.

\item REEL: This is EEL with a non-negativity constraint on all
  implied probabilities. In that case, the maxiter can be used to
  control the number of iterations.

\item Others: When rhoFct is provided or the type is ET, the solution
  is obtained by either ``nlminb'' or ``optim''. In that case, the
  algorithms are controlled through the control argument.
\end{itemize}

Here are a few example using the simulated dataset (convergence code
of 0 means that the algorithm converged with no detected problem):

<<>>=
X <- simData[c("x3","x4","z5")]
(res <- getLambda(X, gelType="EL"))$lambda
res$convergence$convergence
@ 

<<>>=
(res <- getLambda(X, gelType="EL", algo="Wu"))$lambda
res$convergence$convergence
@ 

<<>>=
(res <- getLambda(X, gelType="ET",control=list(maxit=2000)))$lambda
res$convergence$convergence
@ 

The following shows that we can provide getLambda() with a rhoFct instead:

<<>>=
(res <- getLambda(X, rhoFct=rhoEEL))$lambda
res$convergence$convergence
@ 

Although we rarely call the function directly, it is good to
understand how it works, because it is an important part of the
estimation procedure.

\section{Methods for gelModels Classes} \label{sec:gelmodels-methods}

We saw above that any ``gelModels'' is a class that contains one of
the ``gmmModels'' class object.  Therefore, many ``gmmModels'' methods
can be applied to ``gelModels'' through this direct inheritance. when
it is the case, we will specify ``gmmModels inherited method''. 


\begin{itemize}
\item \textit{kernapply}: In the case of weakly dependent moment
  conditions, we saw above that the moment function must be smoothed
  using the following expression:
\[
g^w_t(\theta) = \sum_{s=-m}^m w(s)g_{t-s}(\theta)
\]

When a GEL model is defined with vcov="HAC", the specification of the
kernel is stored in the ``wSpec'' slot of the object. For example, we
can define the linear model above with the HAC specification:

<<>>=
linHAC <- gelModel(y~x1+x2, ~x2+z1+z2, data=simData, vcov="HAC", gelType="EL")  
linHAC
@ 

The optimal bandwidth is computed when the model is created, and
remains the same during the estimation process, unless another one is
specified. The above model shows that the default kernel is the
``Truncated'' one, and the default bandwidth is based on
\cite{andrews91}. The bandwidth is not based on the smoothing kernel,
but on the implied kernel for the HAC estimation. \cite{smith01} shows
that when $g_t(\theta)$ is replaced by $g^w_t(\theta)$,
$V=\sum_{i=1}^n g^w_t(\theta)g^w_t(\theta)'/n$ is an HAC estimator of
the covariance matrix of $\sqrt{n}\bar{g}(\theta)$, with Bartlett
kernel when the smoothing kernel is the Truncated, and with Parzen
kernel when the smoothing kernel is the Bartlett. The optimal bandwidth
above is therefore based on the Bartlett kernel. 

It is possible to modify the specifications of the kernel and
bandwidth through the argument vcovOptions (See help(vcovHAC) from the
sandwich package for all possible options). Notice that the kernel
type that is passed is the kernel used for the HAC estimation, not the
smoothing of $g_t(\theta)$. See in the following example that the
Parzen kernel is selected, which implies a Bartlett kernel for the
smoothing of $g_t(\theta)$.

<<>>=
linHAC2 <- gelModel(y~x1+x2, ~x2+z1+z2, data=simData, vcov="HAC", 
                    gelType="EL", 
                    vcovOptions=list(kernel="Parzen", bw="NeweyWest", prewhite=1))  
linHAC2
@ 

It is also possible to set the bandwidth to a fix number:

<<>>=
linHAC3 <- gelModel(y~x1+x2, ~x2+z1+z2, data=simData, vcov="HAC", 
                    gelType="EL", 
                    vcovOptions=list(kernel="Parzen", bw=3, prewhite=1))  
linHAC3
@ 

The \textit{kernapply} method, which is defined as an S3 method in the
stats package, uses the information contained in the ``wSpec'' slot to
compute the $n\times q$ matrix of moment with the i$^{th}$ row being
$g_t^w(\theta)'$. A theta is required, because we need to evaluate
$g_t(\theta)$.

<<>>=
gw <- kernapply(linHAC, theta=c(1,1,1))$smoothx
head(gw)
@ 

The function also returns the weights, bandwidth, kernel name and the
scalars $k_1$ and $k_2$ that are needed for the asymptotic properties
of the estimators (see \cite{anatolyev05}). If the argument
smooth is set to FALSE, the optimal bandwidth is computed and no
smoothing is done. By default, the first step GMM estimator with the
identity matrix is used, unless theta is provided.

<<>>=
kernapply(linHAC, smooth=FALSE)
@ 

There is also a \textit{kernapply} method for ``gmmModels''
classes. For now, it only returns the optimal bandwidth, the weights, 
the kernel names and the $k_i$'s.

<<>>=
kernapply(as(linHAC, "gmmModels"))
@ 

\item \textit{residuals (gmmModels inherited method)}: Only defined
  for linearGel and nonlinearGel. It returns $\epsilon(\theta)$:

\item \textit{Dresiduals (gmmModels inherited method)}: Only for
  ``linearGel'' and ``nonlinearGel'', it returns the $n\times k$
  matrix $d\epsilon(\theta)/d\theta$:

\item \textit{model.matrix (gmmModels inherited method)}: For
  linearGel and nonlinearGel only. For both classes, it ca be used to
  get the matrix of instruments:

\item \textit{modelResponse (gmmModels inherited method)}: For linear
  model only, it returns the vector of response. It is not defined for
  nonlinearGel classes because the left hand side is not always
  defined.

\item \textit{"[" (gmmModels inherited method)}: It creates a new
  object of the same class with a subset of moment conditions:

\item \textit{as}: ``linearGel'' can be converted into a
  ``nonlinearGel'' or ``functionGmm''. Also, ``nonlinearGel'' and
  ``formulaGel'' can be converted to ``functionGel''

<<>>=
as(lin, "nonlinearGel")
as(nlin, "functionGel")
@   

\item \textit{subset (gmmModels inherited method)}: As for the S3
  method, it creates the same class of object with a subset of the
  sample.

\item \textit{evalMoment}: It computes the $n\times q$ matrix of
  moments, with the $i^{th}$ row being $g_i(\theta)'$, when the
  ``vcov'' slot is not "HAC", and $g_i^w(\theta)'$ when it is.

<<>>=
gt <- evalMoment(linHAC, theta=1:3)
@   
  
\item \textit{evalDMoment}: It computes the $p\times k$ matrix of
  derivatives of the sample mean of $g_i(\theta)$. It calls the next
  method when the slot ``vcov'' is not "HAC". Otherwise, a numerical
  derivative is computed using numericDeric().

\item \textit{momentVcov}: It calls the next method when the slot
  ``vcov'' is not "HAC". Otherwise, it returns 
  
\[
V = \frac{1}{n}\sum_{i=1}^n g_t^w(\theta)g_t^w(\theta)'
\]

\item \textit{update}: This method is used to modify existing
  objects. For now, only the covariance structure, the gelType and
  rhoFct can be modified. 
  
<<>>=
update(lin, vcov="HAC", gelType="ET")
@   

\end{itemize}

\section{Restricted models} \label{sec:gelmodels-rest}

As for ``gmmModels'', restrictions can be imposed on the
coefficients. The union class for all restricted GEL models is
``rgelModels''. The classes are ``rlinearGel'', ``rformulaGel'',
``rfunctionGel'' and ``rnonlinearGel''. Each one contains its
unrestricted model plus additional slots that specify the
constraints. See the gmmS4 vignette for more details. The constructor
is the \textit{restModel} method.

<<>>=
lin2 <- gelModel(y~x1+x2+x3+z1, ~x1+x2+z1+z2+z3+z4, data=simData,
                 gelType="EL", vcov="MDS")
rlin2 <- restModel(lin2, c("x1=x2", "x3=0"))
rlin2
@ 

All methods described in the previous section also apply to the
restricted models. For example, 

<<>>=
e <- residuals(rlin2, theta=c(1,1,1)) ## we now have 3 coefficients
gt <- evalMoment(rlin2, theta=c(1,1,1))
@ 

To recover the full coefficient vector, we use the \textit{coef}
method:

<<>>=
coef(rlin2, theta=1:3)
@ 

\section{The \textit{solveGel} Method} \label{sec:gelmodels-solve}

The main method to estimate a model by GEL methods is
\textit{solveGel}. The available signatures are:

<<>>=
showMethods("solveGel")
@ 

The arguments are 
\begin{itemize}
\item theta0: The initial value for the minimization algorithm. It is
  required if the model does not have a theta0 slot. If it has a
  theta0 slot, it is used by default unless a new theta0 is provided.
\item lambda0: The initial value to pass to the lambda solver. By
  default, it is set to 0, which is its asymptotic value in case of
  correctly specified models.
\item lamSlv: An optional function to solve for lambda. By default,
  getLambda() is used. The function must have the following form:

<<>>=
mylSolve <- function(gmat, lambda0, gelType=NULL, rhoFct=NULL, k=1, ...) 
    {
        lambda <-  rep(0,ncol(gmat))
        obj <-  sum(colMeans(gmat)^2)
        list(lambda=lambda, convergence=0, obj=obj)
    }
@ 

Therefore, it must return a list with lambda, convergence and obj. In
the above example, $\lambda$ is set to a vector of zeros and the
returned obj is $\bar{g}(\theta)'\bar{g}(\theta)$. The solution will
therefore be the one step GMM with the weighting matrix equals to the
identity.

<<>>=
solveGel(lin,c(0,0,0), lamSlv=mylSolve)
@ 

To present a more realistic example, suppose we want to estimate the
model using the exponentially tilted empirical likelihood (ETEL)
method of \cite{schennach07}, we could write a function that solves
the lambda using ET, and returns the empirical log-likelihood ratio:

<<>>=
mylSolve <- function(gmat, lambda0=NULL, gelType=NULL, rhoFct=NULL, k=1, ...) 
    {
        gmat <- as.matrix(gmat)
        res  <-  getLambda(gmat, lambda0, gelType="ET", k=k)
        gml <- c(gmat%*%res$lambda)
        w <- exp(gml)
        w <- w/sum(w)
        n <- nrow(gmat)
        res$obj <- mean(-log(w*n))
        res
    }
etelFit <- solveGel(lin,c(1,1,0), lamSlv=mylSolve)
etelFit$theta
@

That's equivalent to setting gelType to ``ETEL'':

<<>>=
solveGel(update(lin, gelType="ETEL"), c(1,1,0))$theta
@ 

\item coefSlv: A character string that indicates the name of the
  minimization solver used to obtain $\hat{\theta}$. By default,
  "optim" is use. The other options are "nlminb" and "constrOptim". 
  
\item lControl: A list of options for the lambda solver. It is passed
  to getLambda() or lamSlv() if provided. For example, we can use the
  Wu method for EL as follows:

<<>>=
solveGel(lin, c(1,1,0), lControl=list(algo="Wu"))$theta
@   

\item tControl: A list of control for the coefSlv function. We could,
  for example, use the following options:

<<>>=
solveGel(lin, c(1,1,0), lControl=list(algo="Wu"),
         tControl=list(method="BFGS", control=list(maxit=2000, reltol=1e-9)))$theta
@   

In that particular case, the list is directly passed to optim().
   
\end{itemize}

The method returns a list with: theta=$\hat{\theta}$,
lambda=$\hat{\lambda}$, convergence = convergence message and code for
$\theta$, and lconvergence = convergence message and code for
$\lambda$.

\section{The \textit{modelFit} Method} \label{sec:gelmodels-modelfit}

This is the main estimation method. It returns an object of class
``gelfit''. The arguments are:

\begin{itemize}
\item object: Any object that belongs to the union class ``gelModels''
\item getType: Optional type of GEL if we want to estimate the model
  with a type that is different from the one defined in the object.  
\item rhoFct: Optional $\rho(v)$ function if we want to estimate the
  model with a function that is different from the one defined in the
  object.
\item initTheta: Method to obtain the starting value for $\theta$. By
  default, the one step GMM is used. The other option is to use the
  one included in the object.
\item theta0: The stating value for $\theta$. If provided, the
  argument initTheta is ignored.
\item lambda0: Starting value for $\lambda$. By default, a vector of
  zeros is used.
\item vcov: Logical argument that specifes if the covariance matrices
  of $\hat{\theta}$ and $\hat{\lambda}$ should be computed? It is
  FALSE by default.
\item ... : Additional argument that is passed to the
  \textit{gelSolve} method.  
  \end{itemize}

In general, it works fine with the default arguments:

<<warning=FALSE>>=
modelFit(lin)
@ 



\bibliography{empir}
\pagebreak
\Large{\textbf{Appendix}}
\appendix
\section{Some extra codes}

\end{document} 

